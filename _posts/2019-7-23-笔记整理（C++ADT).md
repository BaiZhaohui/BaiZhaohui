### 抽象数据类型
编写程序前，需要清楚地了解如何通过程序来实现索要完成的任务。 编写代码前，应列出程序的提纲（项目越大，越复杂，提纲应越详细），包括其需求。

实现的细节，应该在一个项目的后期完成，实现阶段要用到的详细数据结构更不应该在一开始就指定。

在刚开始的时候，最重要的是每项任务的输入输出。开始阶段应该关心程序需要什么，而不是如何去做。程序的行为比实现程序的机制更重要。如某个项需要完成一些任务，那么应该指定在这个项上进行的操作，而不是指定这个项的内部结构。这些操作是基于这个项的。当明确这些操作之后，就可以开始实现这个程序了。实现决定应该使用哪种数据结构，从而达到更好的时间以及空间执行效率。指定了操作的项被称为抽象数据类型（ADT）。

抽象数据类型不是程序的一部分，因为程序需要定义数据结构，而不只是数据结构上执行的操作。

### 封装
OOP以对象为中心，而对象是用类来定义的。类是一个模板，对象根据类来创建。类是软件的一部分，包括数据的说明以及对数据执行的操作，还可能包含对其他类数据的操作。
类中定义的函数称为方法，或者成员函数或者函数成员，类中使用的变量称为数据成员。
数据及其相关操作的结合称为数据封装。
对象是类的实例，是用类定义创建的实体。  

与非面向对象语言中的函数比，对象使数据和成员函数之间的结合更加紧密，更有意义。在非面向对象编程语言中，数据的声明和函数定义分散在整个程序中，只有程序文档才能说明它们之间存在联系。而OOL中，联系在一开始就建立起来了；事实上，这种联系是程序的基础。对象是由相互关联的数据和操作定义的，同一个程序中可能会有很多对象，对象通过传递消息来相互通信，为了更为充分的通信，需要泄露对象一些内部细节。基于对象的结构化编程可以完成多个目标。

首先，数据与操作之间的强耦合关系在实际的建模过程中非常有用，软件工程尤其强调这一点。
其次，对象便于查找错误，因为操作都只限于它们的对象。即使有副作用也容易跟踪。
第三，对象可以对其他对象隐藏某些操作细节。从而使得这些操作不会受到其他对象的影响，这就是所谓的信息隐藏原则。

对象就像是一个黑盒子，其行为有明确的定义，我们使用对象是因为知道其功能，而不是因为了解其内部运行机制。对象的这种不透明性对于保持其独立性是非常有用的。如果恰当的定义了对象之间的通信管道，那么只有当对象中的改变影响到通信管道时，才会影响其他对象。在了解了对象发出和收到的信息之后，可以方便地用某个在特殊情况下更为合适的对象取代当前对象。

信息隐藏往往容易模糊数据和操作的界限。

C++能够在类声明中使用类型参数来声明通用类。
~~~
template<class genType>
class genClass{
  genType storage[50];
  ..............
  }
  ~~~
  
  此后才会决定如何初始化genType:
  ~~~
  genClass<int> intObject;
  genClass<float> floatObject;
  ~~~
  
这个通用类是生成两个新类（int类型的genClass和float类型的genClass）的基础，然后使用这两个类创建了两个对象intObject和floatObject。通过这种方式，通用类可以根据特定的声明以各种不同的形式出现，一个通用声明就足以使类具有不同的形式。

让storage数组大小可选：
~~~
template<class genType,int size = 50>
class genClass{
  genType storage[size];
};

genClass<int> intObject1; // use the default size;
genClass<int,100> intObject2;
genClass<float,123> floatObject;
